# 1. Зачем нужны ссылки
При выделении памяти нужно гарантировать ее высвобождение. Иначе возникнет утечка памяти.

Чистый `free` не способен это гарантировать. Например при возникновения исключения до вызова `free`. Однако, согласно **RAII**, автоматическая память должна быть разрушена, то есть вызваны соответсвующие деструкторы.

Использование деструкторов в специализированных структурах гарантирует, что память будет высвобождена. Иногда высвобождение не требуется, например, если указатель на статическую память.
# 2. Общее описание
Ссылка - это умный указатель, который контролирует динамически выделенную память. Она состоит непосредственно из указателя на память и указателя на счетчик.

Счетчик состоит из 2 чисел:
 - `слабое` контролирует время жизни динамически выделенного счетчика
 - `сильное` контролирует время жизни выделенной памяти

Существует три типа ссылок:
 - `слабая` обеспечивает простой счет числа ссылок на память
 - `сильная` обеспечивает время жизни памяти и считает число ссылок
 - `неизвестная` ведет себя как `слабая` или `сильная` в зависимости от своей силы, способна менять ее
 - `уникальная` хранит внутри себя указатель на память, высвобождает ее, когда вызывается ее деструктор

#### Использование нескольких счетчиков на один и тот же указатель в случае использования ссылок, кроме слабых, влечет к неопределенному поведению!

Каждая ссылка - шаблон с 2 параметрами
```cpp
//T - это тип указателя
//RC - это тип счетчика
weak_ref<T, RC>     //слабая ссылка
strong_ref<T, RC>   //сильная ссылка
unknown_ref<T, RC>  //неизвестная ссылка
unique_ref<T>       //уникальная ссылка
```
# 3. Счетчик
DTE предоставляет 2 счетчика
```cpp
ref_counter         //type: size_t
atomic_ref_counter  //type: std::atomic<size_t>
```
`ref_counter` является быстрым, но потоконебезопасным.
`atomic_ref_counter` является потокобезопасным, но медленным

К каждому счетчику есть определенные требования, изложенные в `is_ref_counter_v` в заголовке `ref.hpp`.
# 4. Слабая ссылка
Слабая ссылка не влияет на время жизни памяти. Ее основная задача - считать число ссылок.

Конструкторы:
```cpp
weak_ref(pointer instance = nullptr)    //1
weak_ref(const weak_ref& other)         //2
```
1. Создает ссылку на `instance`, число слабых ссылок 1, число сильных 0.
2. Копирует ссылку и увеличивает число слабых ссылок на 1, число сильных ссылок не меняется.
# 5. Сильная ссылка
Сильная ссылка обеспечивает время жизни памяти - пока остаются сильные ссылки. Также увеличивает слабое число ссылок.

Конструкторы:
```cpp
strong_ref(pointer instance = nullptr)                                                                          //1
strong_ref(const strong_ref& other) noexcept                                                                    //2
template<bool is_fail_safe = false>
strong_ref(const weak_ref<T, RC>& other, template_forwarding<bool, is_fail_safe> = {}) noexcept(is_fail_safe)   //3
```
1. Создает ссылку на `instance`, число слабых ссылок 1, число сильных 1.
2. Копирует ссылку и увеличивает число слабых и сильных ссылок на 1.
3. Копирует ссылку как 2, однако может выкидывать исключение в случае, если не is_fail_safe и число сильных ссылок 0.
# 6. Неизвестная ссылка
Незвестная ссылка ведет себя как сильная или слабая ссылка в зависимости от своей силы. При смене применяются свойства приобретаемой ссылки.

Конструкторы:
```cpp
unknown_ref(pointer instance = nullptr, bool strength = false)                                                                          //1
unknown_ref(const unknown_ref& other, bool strength = false)                                                                            //2
template<bool is_fail_safe = false>
unknown_ref(const weak_ref<T, RC>& other, bool strength = false, template_forwarding<bool, is_fail_safe> = {}) noexcept(is_fail_safe)   //3
```
1. Создает ссылку согласно своей силе.
2. Копирует ссылку согласно своей силе.
3. Копирует ссылку как 2, однако может выкидывать исключение в случае, если не is_fail_safe и число сильных ссылок 0.
# 7. Уникальная ссылка
Уникальная ссылка обеспечивает жизнь выделенной памяти до вызова своего деструктора.

Конструкторы:
```cpp
unique_ref(pointer instance = nullptr) noexcept //1
unique_ref(const unique_ref&) = delete;         //2
unique_ref(unique_ref&& other) noexcept         //3
```
1. Создает ссылку на выделенную память
2. Удален, ссылка некопируема
3. Создает ссылку на основе другой, обнуляя ее
# 8. Замечания
Каждая ссылка использует `cdelete` соответсвущего объекта, у слабой - это счетчик, у сильной - это выделенная память. `cdelete` использует `aligned_free`, поэтому будет вызвано необработанное исключение, если память не создана с участием `aligned_xmalloc` (`cnew`).